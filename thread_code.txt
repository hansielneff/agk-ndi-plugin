struct VideoProperties {
    int senderID;
    unsigned char* memblockPtr;
    int memblockID;
    int xres;
    int yres;
    int dataOffset;
};

VideoProperties createVideoProperties(int senderID, int imageID) {
    // AGK image properties and memblock creation
    int imageWidth = (int)agk::GetImageWidth(imageID);
    int imageHeight = (int)agk::GetImageHeight(imageID);
    int memblock = agk::CreateMemblockFromImage(imageID);
    int dataOffset = 12;
    unsigned char* memblockPtr = agk::GetMemblockPtr(memblock);

    return { senderID, memblockPtr, memblock, imageWidth, imageHeight, dataOffset };
}

struct AudioProperties {
    int senderID;
    unsigned char* memblockPtr;
    int memblockID;
    short channelCount;
    short bitsPerSample;
    int sampleRate;
    int frameCount;
    int dataOffset;
};

AudioProperties createAudioProperties(int senderID, int soundID) {
    // AGK sound properties and memblock creation
    int memblock = agk::CreateMemblockFromSound(soundID);
    short channelCount = agk::GetMemblockShort(memblock, 0);    // 1 or 2
    short bitsPerSample = agk::GetMemblockShort(memblock, 2);   // 8 or 16
    int sampleRate = agk::GetMemblockInt(memblock, 4);
    int frameCount = agk::GetMemblockInt(memblock, 8);
    int dataOffset = 12;
    unsigned char* memblockPtr = agk::GetMemblockPtr(memblock);

    return { senderID, memblockPtr, memblock, channelCount, bitsPerSample, sampleRate, frameCount, dataOffset };
}

void sendVideoFrame(VideoProperties videoProps) {
    // Video frame settings
    NDIlib_video_frame_v2_t videoFrame;
    videoFrame.xres = videoProps.xres;
    videoFrame.yres = videoProps.yres;
    videoFrame.FourCC = NDIlib_FourCC_type_RGBA;
    videoFrame.p_data = (uint8_t*)videoProps.memblockPtr + videoProps.dataOffset;

    NDIlib_send_send_video_v2(NDISenders[videoProps.senderID], &videoFrame);
}

void sendAudioFrame(AudioProperties audioProps) {
    // Parse AGK sound data into NDI struct
    NDIlib_audio_frame_interleaved_16s_t interleavedAudio;
    interleavedAudio.no_channels = audioProps.channelCount;
    interleavedAudio.no_samples = audioProps.frameCount;
    interleavedAudio.sample_rate = audioProps.sampleRate;
    interleavedAudio.timecode = 0;
    interleavedAudio.p_data = (int16_t*)audioProps.memblockPtr;

    // Send frame and free memory
    NDIlib_util_send_send_audio_interleaved_16s(NDISenders[audioProps.senderID], &interleavedAudio);
}

DWORD WINAPI videoSenderThread(void* data) {
    if (!data) return 1;

    VideoProperties* args = (VideoProperties*)data;

    // Run until signaled to stop
    while (senderThreadSignals[args->senderID] == THREAD_RUN)
        sendVideoFrame(*args);

    return 0;
}

DWORD WINAPI audioSenderThread(void* data) {
    if (!data) return 1;

    AudioProperties* args = (AudioProperties*)data;

    // Run until signaled to stop
    while (senderThreadSignals[args->senderID] == THREAD_RUN)
        sendAudioFrame(*args);

    return 0;
}

extern "C" DLL_EXPORT void StartSendingVideo(int senderID, int imageID) {
    // Create new thread to handle video sending
    senderThreadSignals[senderID] = THREAD_RUN;
    VideoProperties videoProps = createVideoProperties(senderID, imageID);
    HANDLE thread = CreateThread(NULL, 0, videoSenderThread, &videoProps, 0, &senderThreadIDs[senderID]);
    if (!thread) return;

    // Register memblock ID, so we can delete it when thread halts
    senderMemblocks[senderID] = videoProps.memblockID;

    // Sleep and then halt (TESTING)
    agk::Sleep(10000);
    senderThreadSignals[senderID] = THREAD_HALT;
}

extern "C" DLL_EXPORT void StartSendingAudio(int senderID, int soundID) {
    // Create new thread to handle audio sending
    senderThreadSignals[senderID] = THREAD_RUN;
    AudioProperties audioProps = createAudioProperties(senderID, soundID);
    HANDLE thread = CreateThread(NULL, 0, audioSenderThread, &audioProps, 0, &senderThreadIDs[senderID]);
    if (!thread) return;

    // Register memblock ID, so we can delete it when thread halts
    senderMemblocks[senderID] = audioProps.memblockID;

    // Sleep and then halt (TESTING)
    agk::Sleep(10000);
    senderThreadSignals[senderID] = THREAD_HALT;
}